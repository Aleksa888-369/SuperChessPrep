/**
 * Lazy Loading Utility
 * Generated by mega_patch.py
 * 
 * Usage:
 *   <img data-src="image.jpg" class="lazy">
 *   LazyLoader.init()
 */
(function() {
    'use strict';
    
    const LazyLoader = {
        observer: null,
        
        init: function(options = {}) {
            const config = {
                rootMargin: options.rootMargin || '50px 0px',
                threshold: options.threshold || 0.01,
                selector: options.selector || '.lazy, [data-src]'
            };
            
            // Use IntersectionObserver if available
            if ('IntersectionObserver' in window) {
                this.observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            this.loadImage(entry.target);
                            this.observer.unobserve(entry.target);
                        }
                    });
                }, {
                    rootMargin: config.rootMargin,
                    threshold: config.threshold
                });
                
                // Observe all lazy images
                document.querySelectorAll(config.selector).forEach(img => {
                    if (img.dataset.src) {
                        this.observer.observe(img);
                    }
                });
                
                Logger.debug('[LazyLoader] Initialized with IntersectionObserver');
            } else {
                // Fallback: Load all immediately
                this.loadAll(config.selector);
                Logger.warn('[LazyLoader] IntersectionObserver not supported, loading all');
            }
        },
        
        loadImage: function(img) {
            const src = img.dataset.src;
            if (!src) return;
            
            // Create temp image to preload
            const tempImg = new Image();
            tempImg.onload = function() {
                img.src = src;
                img.classList.remove('lazy');
                img.classList.add('lazy-loaded');
                img.removeAttribute('data-src');
            };
            tempImg.onerror = function() {
                Logger.warn('[LazyLoader] Failed to load:', src);
                img.classList.add('lazy-error');
            };
            tempImg.src = src;
        },
        
        loadAll: function(selector) {
            document.querySelectorAll(selector).forEach(img => {
                this.loadImage(img);
            });
        },
        
        refresh: function() {
            if (this.observer) {
                document.querySelectorAll('.lazy, [data-src]').forEach(img => {
                    if (img.dataset.src) {
                        this.observer.observe(img);
                    }
                });
            }
        },
        
        destroy: function() {
            if (this.observer) {
                this.observer.disconnect();
                this.observer = null;
            }
        }
    };
    
    // Auto-init on DOMContentLoaded
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => LazyLoader.init());
    } else {
        LazyLoader.init();
    }
    
    // Expose globally
    window.LazyLoader = LazyLoader;
})();
