/**
 * Enhanced EventManager - Automatic event listener cleanup
 * Generated by mega_patch.py
 * 
 * Usage:
 *   EventManager.on(element, 'click', handler)
 *   EventManager.off(element, 'click', handler)
 *   EventManager.cleanup() - Remove all listeners
 *   EventManager.cleanupElement(element) - Remove listeners for specific element
 */
(function() {
    'use strict';
    
    const listeners = new Map();
    let globalId = 0;
    
    const EventManager = {
        /**
         * Add event listener with automatic tracking
         * @param {Element|Window|Document} element - Target element
         * @param {string} event - Event type
         * @param {Function} handler - Event handler
         * @param {Object|boolean} options - Event options
         * @returns {number} Listener ID for manual removal
         */
        on: function(element, event, handler, options = false) {
            if (!element || typeof handler !== 'function') {
                Logger.warn('[EventManager] Invalid element or handler');
                return -1;
            }
            
            const id = ++globalId;
            const wrappedHandler = function(e) {
                try {
                    handler.call(this, e);
                } catch (err) {
                    Logger.error('[EventManager] Handler error:', err);
                }
            };
            
            element.addEventListener(event, wrappedHandler, options);
            
            listeners.set(id, {
                element,
                event,
                handler: wrappedHandler,
                originalHandler: handler,
                options
            });
            
            return id;
        },
        
        /**
         * Remove event listener by ID
         * @param {number} id - Listener ID
         */
        offById: function(id) {
            const listener = listeners.get(id);
            if (listener) {
                listener.element.removeEventListener(
                    listener.event, 
                    listener.handler, 
                    listener.options
                );
                listeners.delete(id);
            }
        },
        
        /**
         * Remove event listener by element, event, and handler
         * @param {Element} element - Target element
         * @param {string} event - Event type
         * @param {Function} handler - Original handler
         */
        off: function(element, event, handler) {
            listeners.forEach((listener, id) => {
                if (listener.element === element && 
                    listener.event === event && 
                    listener.originalHandler === handler) {
                    this.offById(id);
                }
            });
        },
        
        /**
         * Remove all listeners for a specific element
         * @param {Element} element - Target element
         */
        cleanupElement: function(element) {
            const toRemove = [];
            listeners.forEach((listener, id) => {
                if (listener.element === element) {
                    toRemove.push(id);
                }
            });
            toRemove.forEach(id => this.offById(id));
            Logger.debug(`[EventManager] Cleaned up ${toRemove.length} listeners for element`);
        },
        
        /**
         * Remove all tracked listeners
         */
        cleanup: function() {
            const count = listeners.size;
            listeners.forEach((listener, id) => {
                listener.element.removeEventListener(
                    listener.event,
                    listener.handler,
                    listener.options
                );
            });
            listeners.clear();
            Logger.debug(`[EventManager] Cleaned up ${count} listeners`);
        },
        
        /**
         * Get count of active listeners
         * @returns {number}
         */
        getCount: function() {
            return listeners.size;
        },
        
        /**
         * Add one-time event listener
         * @param {Element} element - Target element
         * @param {string} event - Event type
         * @param {Function} handler - Event handler
         * @param {Object|boolean} options - Event options
         */
        once: function(element, event, handler, options = false) {
            const self = this;
            const id = this.on(element, event, function onceHandler(e) {
                self.offById(id);
                handler.call(this, e);
            }, options);
            return id;
        },
        
        /**
         * Add throttled event listener
         * @param {Element} element - Target element
         * @param {string} event - Event type
         * @param {Function} handler - Event handler
         * @param {number} limit - Throttle limit in ms
         */
        throttled: function(element, event, handler, limit = 100) {
            if (typeof throttle === 'function') {
                return this.on(element, event, throttle(handler, limit));
            }
            return this.on(element, event, handler);
        },
        
        /**
         * Add debounced event listener
         * @param {Element} element - Target element
         * @param {string} event - Event type
         * @param {Function} handler - Event handler
         * @param {number} delay - Debounce delay in ms
         */
        debounced: function(element, event, handler, delay = 300) {
            if (typeof debounce === 'function') {
                return this.on(element, event, debounce(handler, delay));
            }
            return this.on(element, event, handler);
        }
    };
    
    // Auto-cleanup on page unload
    window.addEventListener('beforeunload', function() {
        EventManager.cleanup();
    });
    
    // Cleanup on visibility change (tab close)
    document.addEventListener('visibilitychange', function() {
        if (document.visibilityState === 'hidden') {
            // Optional: Log stats before potential close
            Logger.debug(`[EventManager] Page hidden, ${EventManager.getCount()} active listeners`);
        }
    });
    
    // Expose globally
    window.EventManager = EventManager;
    
    Logger.debug('[EventManager] Enhanced EventManager loaded');
})();
